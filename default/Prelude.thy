(* Author:     Tobias Rittweiler, Florian Haftmann, TU Muenchen
*)

header {* Base environment for theories generated by the Haskell importer. *}

theory Prelude
imports Main
begin

text {*
  You can place here what you want.  However, in practice it
  is recommended to restrict additions here only to ingredients
  of the Haskell Prelude;  further Haskell library modules
  should be obtained in source and just imported, probably
  with prior modifications.
*}

subsection {* Fundamental prelude ingredients *}

axiomatization error :: "string \<Rightarrow> 'a"

definition rapp :: "('a \<Rightarrow> 'b) \<Rightarrow> 'a \<Rightarrow> 'b" (infixr "$" 60) where
  "f $ x = f x"

definition curry :: "('a \<times> 'b \<Rightarrow> 'c) \<Rightarrow> 'a \<Rightarrow> 'b \<Rightarrow> 'c" where
  "curry f x y = f (x, y)"

definition uncurry :: "('a \<Rightarrow> 'b \<Rightarrow> 'c) \<Rightarrow> 'a \<times> 'b \<Rightarrow> 'c" where
  "uncurry = split"

definition nth :: "'a list \<Rightarrow> int \<Rightarrow> 'a" where
  "nth xs k = (if k < 0 then error ''negative index'' else List.nth xs (nat k))"

definition length :: "'a list \<Rightarrow> int" where
  "length xs = int (List.length xs)"

definition replicate :: "int \<Rightarrow> 'a \<Rightarrow> 'a list" where
  "replicate k = List.replicate (nat k)"

primrec separate :: "'a \<Rightarrow> 'a list \<Rightarrow> 'a list" where
    "separate x [] = []"
  | "separate x (y # ys) = (if ys = [] then [y] else y # x # separate x ys)"

subsection {* Counterparts for fundamental Haskell classes *}

class eq =
  fixes equal :: "'a \<Rightarrow> 'a \<Rightarrow> bool"
  fixes inequal :: "'a \<Rightarrow> 'a \<Rightarrow> bool"
  assumes inequal_equal [simp]: "inequal x y \<longleftrightarrow> \<not> equal x y"

instantiation bool :: eq
begin

definition
  "equal p q \<longleftrightarrow> (p \<longleftrightarrow> q)"

definition
  "inequal p q \<longleftrightarrow> \<not> (p \<longleftrightarrow> q)"

instance proof
qed (simp_all add: equal_bool_def inequal_bool_def)

end

instantiation unit :: eq
begin

definition
  "equal (u::unit) v \<longleftrightarrow> True"

definition
  "inequal (u::unit) v \<longleftrightarrow> False"

instance proof
qed (simp_all add: equal_unit_def inequal_unit_def)

end

instantiation * :: (eq, eq) eq
begin

definition
  "equal x y \<longleftrightarrow> (x :: _ * _) = y"

definition
  "inequal x y \<longleftrightarrow> (x :: _ * _) \<noteq> y"

instance proof
qed (simp_all add: equal_prod_def inequal_prod_def)

end

instantiation list :: (eq) eq
begin

definition
  "equal x y \<longleftrightarrow> (x :: _ list) = y"

definition
  "inequal x y \<longleftrightarrow> (x :: _ list) \<noteq> y"

instance proof
qed (simp_all add: equal_list_def inequal_list_def)

end

instantiation option :: (eq) eq
begin

definition
  "equal x y \<longleftrightarrow> (x :: _ option) = y"

definition
  "inequal x y \<longleftrightarrow> (x :: _ option) \<noteq> y"

instance proof
qed (simp_all add: equal_option_def inequal_option_def)

end

instantiation int :: eq
begin 

definition
  "equal x y \<longleftrightarrow> x = (y::int)"

definition
  "inequal x y \<longleftrightarrow> x \<noteq> (y::int)"

instance proof
qed (simp_all add: equal_int_def inequal_int_def)

end


class ord = eq + linorder

instance int :: ord ..


class print =
  fixes print :: "'a \<Rightarrow> string"

instantiation list :: (print) print
begin

definition
  "print xs = ''['' @ concat (separate '', '' (map print xs)) @ '']''"

instance ..

end


class num = number_ring + abs + sgn + eq + print

instance int :: num ..


end
