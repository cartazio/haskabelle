(* Author:     Tobias Rittweiler, Florian Haftmann, TU Muenchen
*)

header {* Base environment for theories generated by the Haskell importer. *}

theory Prelude
imports Main
begin

text {*
  You can place here what you want.  However, in practice it
  is recommended to restrict additions here only to ingredients
  of the Haskell Prelude;  further Haskell library modules
  should be obtained in source and just imported, probably
  with prior modifications.
*}

subsection {* Counterparts for fundamental Haskell classes *}

class eq =
  fixes equal :: "'a \<Rightarrow> 'a \<Rightarrow> bool"
  fixes inequal :: "'a \<Rightarrow> 'a \<Rightarrow> bool"

instantiation int :: eq
begin 

definition
  "equal x y \<longleftrightarrow> x = (y::int)"

definition
  "inequal x y \<longleftrightarrow> x \<noteq> (y::int)"

instance ..

end

class print =
  fixes print :: "'a \<Rightarrow> string"

class num = number_ring + abs + sgn + eq + print

instance int :: num ..


subsection {* Fundamental prelude ingredients *}

definition rapp :: "('a \<Rightarrow> 'b) \<Rightarrow> 'a \<Rightarrow> 'b" (infixr "$" 60) where
  "f $ x = f x"


subsection {* Somehow arbitrary additions *}

primrec hsk_foldr :: "('b => 'a => 'a) => 'a => 'b list => 'a" where
    "hsk_foldr f a (x # xs) = f x (hsk_foldr f a xs)"
  | "hsk_foldr f a Nil = a"

fun zipWith :: "('a => 'b => 'c) => 'a list => 'b list => 'c list" where
    "zipWith z (a # as) (b # bs) = (z a b # zipWith z as bs)"
  | "zipWith _ _ _ = Nil"

fun list_and :: "(bool list) \<Rightarrow> bool" where
    "list_and Nil = True"
  | "list_and (True # xs) = list_and xs"
  | "list_and (False # _) = False"

end
