
Grundzüge der Implementierung des Hsimp:
**********************************************************************++

Es gibt im Groben 5 Phasen:

  * Parsing

      Eingabe: Haskell Sourcetext

      Ausgabe: Haskell AST

      Kurzbeschreibung: 

         Parsen, Source File Dependencies auflösen


  * Präprozessierung 

      Eingabe: Haskell AST
      
      Ausgabe: Haskell AST, Global Environment

      Kurzbeschreibung:

        Normalisierung des Haskell AST für unsere Zwecke;
        Erstellung der GlobalE (Umgebung die Informationen über alle
        Identifiers enthält)


  * Konvertierung

      Eingabe: Haskell AST, Global Environment

      Ausgabe: Isa/HOL AST

      Kurzbeschreibung:

        Analyse der Definition Interdependencies, 
        Konvertierung des Haskell ASTs zu einem Isar/HOL AST.


  * Adaption

      Eingabe: Isar/HOL AST, Global Environment

      Ausgabe: adaptierter Isar/HOL AST, adaptiertes Global Environment

      Kurzbeschreibung:

        Mappt Haskell Funktionen, Datatypes, Klassen etc. auf deren
        bereits existierende Pendants in Isar/HOL; hier werden also
        Identifiers umbenannt.


  * Printing

     Eingabe: adaptierter Isar/HOL AST, adaptiertes Global Environment

     Ausgabe: Isar/HOL Sourcetext

     Kurzbeschreibung:

       Konverterung des Isar/HOL ASTs in eigentliche Isar/HOL Syntax.


Im Folgenden werde ich nun jede dieser Phasen etwas genauer beschreiben,
und insbesondere darauf eingehen wo Du das im Source Code finden kannst.


Parsing:
===========================

  Importer.hs ist der Einstiegspunkt. In Importer/ConversionUnit.hs
  werden dann die die Imports aufgelöst, und all die relevanten Haskell
  Sources werden in eine sogenannte ConversionUnit gepackt. 

  Unterstützt werden nur Imports eigener Module, da a) der Sourcecode
  von den Standardmodulen i.d.R. nicht verfügbar ist, und b) diese
  höchstwahrscheinlich eh aus Haskellcode bestehen, der zu komplex ist
  für den Hsimp.

  Wir benutzen Language.Haskell.Exts [1] zum Parsen der Source Files.

Randnotiz:
--------------------------
  Von Importer.hs, nachdem wir eine ConversionUnit haben, wird
  convertHskUnit in Importer/Convert.hs aufgerufen, welche den ganzen
  Prozess steuert, also all die Phasen (bis auf Printing) aufruft. Ich
  werde convertHskUnit noch dementsprechend kommentieren, damit die
  unterschiedlichen Phasen ersichtlich werden.
--------------------------         


Präprozessierung:
===========================

  Die eigentliche Normalisierung des Haskell ASTs kannst Du in
  Importer/Preprocess.hs finden. Hierbei werden folgende Dinge
  normalisiert:

    1) Guards werden aufgelöst.

         foo x y | x > y     = 1
                 | x == y    = 0
                 | otherwise = -1

         wird zu

         foo x y = if x > y then 1
                            else if x == y then 0
                                           else -1

    2) Funktionen werden delokalisiert, d.h. lokale Funktions
       Definitionen werden global gemacht:

         foo x y = frob x y
           where frob x y = x + y
  
         wird zu

         frob0 x y = x + y

         foo x y = frob0 x y

      Jede lokale Funktion bekommt dabei einen neuen, eindeutigen
      Bezeichner, damit gleichnamige lokale Funktionen unterstützt
      werden. Deswegen ist es an dieser Stelle auch nötig, eine Art
      Alpha-Konvertierung (cf. Lambda-Kalkül) durchzuführen, also
      Identifiers semantisch korrekt umzubennen.

      Closures werden hierbei nicht unterstützt. Das heißt z.B.
   
         quux n xs = map frob xs
           where frob offset = n + offset

      liefert einen Fehler. Dies müsste umgeschrieben werden zu

         quux n xs = map (frob n) xs
           where frob n offset = n + offset

      und würde dann zu

         frob1 n offset = n + offset   -- frob1, wegen obigen frob0.

         quux n xs = map (frob1 n) xs

Randnotiz:
--------------------------         
  Importer/Utilities/Hsk.hs enthält Utilities die auf den Haskell AST
  fungieren. Darunter fällt auch renameFreeVars, welches dazu verwendet
  wird, Identifier semantisch korrekt umzubenennen.
--------------------------         

    3) As-Patterns werden aufgelöst.

         foo all@(_:xs) = all ++ xs

         wird zu

         foo all = case all of
                     _:xs -> all ++ xs

    4) Bezeichner werden normalisiert. In Isar/HOL gibt es eine Reihe
       von Keywords und Namen von Konstanten, die nicht als Namen für
       neue Funktionen herangezogen werden dürfen. Diese stehen in
       `used_const_names' und `reserved_keywords' in
       Importer/Adapt/Raw.hs (was es mit dieser Datei auf sich hat,
       später mehr dazu in Adaption.)

       Z.b. ist `append' bereits der Name einer Konstante. Deswegen:

          append [] ys     = ys
          append (x:xs) ys = x : append xs ys

          wird zu

          append0 [] ys      = ys
          append0 (x:xs) ys  = x : append0 xs ys

  Um den Haskell AST zu transformieren, benutze ich die Uniplate
  Bibliothek [2].

  Nach dieser Präprozessierung wird die globale Umgebung
  kreiert. Beachte, dass es an dieser Stelle keine lokalen Definitionen
  mehr gibt, d.h. es existieren nur noch Topdecls. Der Code hierzu
  findest Du in Importer/LexEnv.hs. 

  Die Globale Umgebung wird benutzt um

    a) Identifier (modulkorrekt) aufzulösen.

    b) Informationen über Identifier zu erhalten, also ob ein Identifier
    z.B. eine Funktion repräsentiert, oder einen InfixOp (wenn ja,
    welche Bindingpriorität und Assoziationstyp dieser Op hat.), eine
    Klasse, oder usw.


Konvertierung:
===========================

  In Haskell können Definitionen irgendwo innerhalb einer Datei stehen,
  insbesondere kann eine definierte Funktion vor ihrer Definition
  benutzt werden. Dies ist in Isar/HOL nicht möglich, hier müssen die
  Definitionen linearisiert werden, also

    a) Definitionen müssen vor ihrer Benutztung auftreten.

    b) Gegenseitig rekursive Funktionen müssen in derselben "fun"
       Isar/HOL Definition auftreten.

  Hierzu dient Importer/DeclDependencyGraph.hs welches einen
  Abhängigkeitsgraphen der Definitionen erstellt, und diesen dann
  linearisiert ausgibt. Daraus macht dann converHskUnit ein HskModul das
  aus HskDependentDecls besteht. Dieses HskModul ist dann der
  Einstiegspunkt in die eigentliche Konvertierung.

Randnotiz:
--------------------------         
  Language.Haskell.Exts benutzt als Namensschema `HsFoo'. Ich benutze im
  Hsimp `HskFoo', so dass man besser unterscheiden kann, was wozu
  gehört. Also `HskModule' entspricht dem `HsModule' von
  Language.Haskell.Exts, mit dem Unterschied, dass es nicht `HsDecl's,
  sondern `HskDependentDecls' enthält.
--------------------------         

 Zur eigentlichen Konvertierung gibts es folgendes zu sagen:

   * Es wird soweit möglich auf die Highlevel Kommandos von Isar/HOL
     konvertiert, also insbesondere das "fun", das "definition" und das
     "datatype" Kommando.

   * Die Definition des Isar/HOL AST kannst Du in Importer/IsaSyntax.hs
     finden.

   * Es wird eine Globale State Monade ContextM benutzt, die insbesondere
     die globale Umgebung enthält.

   * Der geparste AST von Language.Haskell.Ext hat InfixOps gemäß ihrer
     Binding Prioritäten _nicht_ aufgelöst, also

       `x + y * z' wird in geparsed als `(x + y) * z', d.h. in etwa

          (HsInfixApp (HsInfixApp (HsVar x) (HsOp +) (HsVar y))
                      (HsOp *) (HsVar z))

       anstatt `x + (y * z)', d.h.

          (HsInfixApp (HsVar x) (HsOp +)
                      (HsInfixApp (HsVar y) (HsOp *) (HsVar z)))

     Die Auflösung und Transformation erledigt `fixOperatorFixities' in
     Importer/Convert.hs, die dazu die Prioritäten etc. der Ops aus der
     Global Umgebung in der ContextM Monade herzieht.

   * Language.Haskell.Ext ist lediglich ein Parser. Er stellt keine
     Typinferenz zur Verfügung. Eine eigene Typinferenz zu schreiben,
     war uns zu aufwändig, deswegen haben wir darauf verzichtet, und
     konvertieren einfach. Wir überlassen das Ganze also der Typinferenz
     von Isabelle. (Natürlich werden explizite Typannotation gemerkt
     (insbesondere in der globalen Umgebung) und konvertiert
     ausgegeben.)


Adaption:
===========================

  Adaption ist das Mappen von Haskell Identifiers, nach Isar/HOL
  Identifiers. 

  Die dazu herangezogene Tabelle `raw_adaption_table' befindet sich in
  Importer/Adapt/Raw.hs. Diese Datei ist jedoch _generiert_, und zwar
  von misc/mk_adapt.ML bzw. bin/mk_adapt, die dazu misc/adapt.txt
  heranzieht. Das Skript benutzt Isabelle um die Namen in adapt.txt
  aufzulösen, und die Bindingprioritäten etc. von Ops aus dem System
  herauszufinden. (Du benötigst hierfür einen Checkout aus dem Isabelle
  CVS, Isabelle2008 tuts nicht.)

Randnotiz:
--------------------------         
  Adaptiert wird entweder direkt auf Isar/HOL Konstanten, z.B. wird (++)
  zu List.append, soweit dies möglich ist. Für komplexere Sachen kann
  auf Definitionen in misc/Prelude.thy mappen, welche Datei für das
  eigentliche Hereinladen in Isabelle als Kontext benutzt
  wird. Z.B. gibt es kein Pendant zu `zipWith' in Isar/HOL, deswegen
  definiert misc/Prelude.thy diese Funktion.
--------------------------         

  Der eigentliche Code zur Adaption findest du in
  Importer/Adapt/Adaption.hs.

  Hierbei muss zum einen der Isar/HOL AST adaptiert werden
  (`adaptIsaUnit'), jedoch muss auch die globale Umgebung adaptiert
  werden (`adaptGlobalEnv'), da diese während der Präprozessierung aus
  den Haskell-Identifiers erzeugt worden ist, und sie nach der Adaption
  somit nicht mehr akkurat wäre.


Printing
===========================

  Der Printer wird durch `pprintConversionUnit' in Importer.hs
  aufgerufen. Der eigentliche Printer wird jedoch in Importer/Printer.hs
  definiert.

  Wir benutzen hier die Bibliothek Text.PrettyPrint, um den Sourcetext
  indentiert ausgegeben.

  Hier gibt es Folgendes zu erwähnen:

    * Wir versuchen, nicht alles unnötigerweise explizit zu Klammern,
      sondern in einem Maße, so dass der resultierende Sourcetext vom
      Menschen gelesen werden kann.

    * Listen wie [1,2,3,4] wurden intern zu einem (1:(2:(3:(4:nil))))
      AST konvertiert; wir wandeln dies wieder nach [1,2,3,4] um.

    * Methodenname in Instances für eine Klasse `foo' müssen in Isar/HOL
      wie folgt aussehen: bar_foo, quux_foo usw.

  Für diese Punkte wird im Printer auch die adaptierte globale Umgebung
  gebraucht.


_________________ Fußnoten: ______________________

[1] http://www.cs.chalmers.se/~d00nibro/haskell-src-exts/
    
    Am besten aus der Darcs Repo auschecken, ich habe ein paar Bugs dem
    Autor gemailt, die er in der Repo gefixt hat.

[2] http://www-users.cs.york.ac.uk/~ndm/uniplate/
