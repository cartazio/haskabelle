
Momentan wird die do-Notation von Haskell noch nicht vom Importer
unterstützt. Ich möchte Dir kurz beschreibe, wie ich normalerweise
vorgehe, wenn ich den Importer um neue Syntax erweitern will:


  1. Ich kreiere eine .hs Datei, die die Syntax möglichst minimalistisch
     benutzt, also z.B.

        module Foo where

        quux z = do let x = 42
                    y <- frob x z
                    return y

  2. Ich schaue, was für einen AST der Parser daraus macht. Dazu benutze
     ich GHCI:

        ghci> :cd ~/hacking/hsimp/
        ghci> :load Importer.hs
        Main> do foo <- Language.Haskell.Exts.parseFile "/tmp/Foo.hs";
                 return (Text.PrettyPrint.text $
                          Importer.Utilities.Misc.prettyShow foo)

  3. Ich öffne Syntax.hs in Language/Haskell/Exts/ in den Sourcen von
     haskell-src-exts, und schaue mir die betreffenden Datentypen an,
     die zu der Syntax gehören.

  4. Ich entscheide mich, ob die Syntax als syntaktischer Zucker in der
     Präprozessing-Phase wegnormalisiert werden soll, oder ob
     stattdessen wirklich eine Konvertierung stattfinden soll.

       Wenn Präprozessing: 

          Im Grunde muss man nun nur Importer/Process.hs verändern, und
       dort eine Präprozessierungphase einfügen. Du musst dabei aber auf
       die Reihenfolge aufpassen, in der normalisiert wird. Wenn du dir
       z.B. preprocessHs.ModuleName dort anschaust, so siehst du, dass zuerst
       die Guards wegnormalisiert werden. Der Grund ist, dass die
       Delokalization Guards nicht versteht, deswegen müssen diese also
       vorher wegnormalisiert werden.

       Wenn Konvertierung: 

          Hierbei kann es von Nöten sein, den Isar/HOL AST zu erweitern,
        dies tust Du in Importer/IsaSyntax.hs.
 
          Im ganzen Importer checke ich mit asserts die Konsistenz. So
        dass du einfach mal den Konverter über /tmp/Foo.hs laufen
        lassen kannst; du wirst dann schon sehen, wo er hängen bleibt:

            do foo <- convertFile "/tmp/Foo.hs";
               return (pprintConversionUnit foo)

          Zuerst wird er wohl in Importer/Utilities/Hsk.hs in
        renameFreeVars stecken bleiben. Dann fügst du den relevanten
        Code dazu ein. Dann probierst du wieder obiges Kommando, und
        er wird wohl in Convert.hs stecken bleiben. Usw. (Er wird dann
        wohl in Adaption.hs, und dann in Printer.hs stecken bleiben,
        danach sollte er durchlaufen.)

     Ich hätte ListComprehensions z.B. per Preprocessing auflösen
     können; dies versuchte ich auch zuerst, indem ich 
     [ f x | x <- foo ] auflöste wie im Haskell98 Report angedeutet.

     Ich hab mich jedoch dann doch entschieden, das ganze zu
     Konvertieren, habe dann in IsaSyntax die Terms um ListComp
     erweitert, usw, da Isar/HOL auch ListComprehensions versteht, und
     das ganze so für den Menschen lesbarer wird.

  5. in ex/src_hs/*.hs findest du lauter Testfälle. Du kannst mit
     ./bin/import_all die alle laufen lassen. Am besten du schaust dir
     vorher an, weche Fälle nicht erfolgreich sind. Dann machst Du Deine
     Veränderungen, und schaust durch deine Modifikationen vllt. neue
     Fälle nicht erfolgreich sind.


  6. Ich erweitere /tmp/Foo.hs um einige komplexere Sachen, prüfe dass
     alles funktioniert, und verschiebe dann diese Datei (besser
     benannt) nach ex/src_hs/.

  -T.
