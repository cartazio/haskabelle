
*** Subset of Haskell 98:

 * Toplevel Function Declarations

     fib 0 = 0
     fib 1 = 1
     fib n = fib (n - 1) + fib (n - 2)

        ==>

     fun fib
     where
       "fib (0::_::num) = (0::_::num)"
     | "fib (1::_::num) = (1::_::num)"
     | "fib n = (fib (n - (1::_::num)) + fib (n - (2::_::num)))"


 * Local Function Declarations

     square_list xs = map square xs
       where square x = x * x

         ==>

     fun square0
     where
       "square0 x = (x * x)"
 
     fun square_list
     where
       "square_list xs = map square0 xs"

   But NO closures:

      scale_list n xs = map (\x -> n * x) xs

          ==> error

   You can use either

      scale_list n xs = map (\x -> n * x) xs

   or

      scale_list_2 n xs = map (* n) xs

          ==>

      fun scale_list
      where
        "scale_list n xs = map (% x . n * x) xs"
 
      fun scale_list_2
      where
        "scale_list_2 n xs = map (% arg0 . arg0 * n) xs"


 * Algebraic Data Types

      data Nat = Zero | Suc Nat

      add_nat Zero y    = y
      add_nat (Suc x) y = Suc (add_nat x y)

          ==>

      datatype Nat = Zero
                   | Suc Nat
 
      fun add_nat
      where
        "add_nat Zero y = y"
      | "add_nat (Suc x) y = Suc (add_nat x y)"


 * Pattern Guards

      signum n | n > 0     = 1
               | n < 0     = -1
               | otherwise = 0

           ==>

      fun signum
      where
        "signum n = (if n > (0::_::num) then (1::_::num)
                     else if n < (0::_::num) then uminus (1::_::num) else (0::_::num))"


 * List Comprehensions

      scale_list_3 n xs = [ n * x | x <- xs ]

            ==>

      fun scale_list_3
      where
        "scale_list_3 n xs = ([n * x . x <- xs])"


 * Type classes

       class Monoid a where
         nothing :: a
         plus    :: a -> a -> a

       instance Monoid Nat where
         nothing = Zero
         plus    = add_nat

       summ :: (Monoid a) => [a] -> a
       summ [] = nothing
       summ (x:xs) = plus x (summ xs)

            ==>

       class Monoid = type +
         fixes nothing :: 'a
         fixes plus :: "'a => 'a => 'a"
 
       instantiation Nat :: Monoid
       begin
   
        definition nothing_Nat :: "Nat"
        where
          "nothing_Nat = Zero"
   
        definition plus_Nat :: "Nat => Nat => Nat"
        where
          "plus_Nat = add_nat"
 
      instance ..
      end
 
      fun summ :: "('a :: Monoid) list => ('a :: Monoid)"
      where
        "summ Nil = nothing"
      | "summ (x # xs) = plus x (summ xs)"


  * What's missing?

      - Infix Declarations (half-way in there)
      
      - Records (half-way in there)

      - Monads, and `do'

      - Extending the mapping between Haskell identifiers (functions,
        datatypes, classes) to their Isabelle pendants.

      - documentation (in progress..)


*** Short Overview over the Implementation of Hsimp:

  5 Phases:

     1. Parsing:  
     
          - uses Language.Haskell.Exts to parse Haskell source files.

          - resolves module dependencies


     2. Preprocess:

          - uses Uniplate to frob the Haskell AST

          - normalizes the Haskell AST:

               * rewrites guards to nested if-expressions.

               * extracts local function declarations, 
                 makes their names unique, 
		 makes them toplevel declarations,
                 renames original identifiers appropriately.

               * resolves As-patterns.

               * renames identifiers if they clash with reserved keywords
                 or already used constant names in Isabelle.


      3. Convert:

           - builds a Declaration Dependency AST, and linearizes it.

           - converts the Haskell AST to an Isar/HOL AST.


      4. Adapt:

           - maps Haskell identifiers in the Isar/HOL AST to appropriate
             names in Isar/HOL.

           - i.e. adapts Haskell Prelude functions / datatypes / type classes
             to already existing pendants in Isabelle, or to user-defined
             pendants.

           - highly customizable by the user. (Prelude.thy)

       
       5. Printing:

           - uses Text.PrettyPrint.HughesPJ pretty-printer combinators.

           - outputs the Isar/HOL AST in actual Isar/HOL syntax.

           - formats the output human-readably.
