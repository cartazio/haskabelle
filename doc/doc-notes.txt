
* Motivation behind Haskabelle

    Isar/HOL can be regarded as a combination of a functional programming
    language and logic. Just like functional programming languages, it has its
    foundation in the typed lambda calculus, but is additionally crafted to
    allow the user to write arbitrary mathematical theorems in a structured and
    convenient way. Its primary realm of application is machine-aided proof
    and verification of such theorems.

    Haskell is a functional programming language that has succeeded in getting
    more and more momentum, not only in academia but increasingly also in
    industry. It is used for /all/ kinds of programming tasks despite (or,
    perhaps, rather because) of its pureness, that is its complete lack of
    side-effects.

    This pureness makes Haskell relate to Isar/HOL more closely than other
    functional languages. In fact, Isar/HOL can be considered a subset[*] of
    Haskell---a subset which is semantically more restrictive to enable
    automatic reasoning.

    Writing a converter from the convertable subset of Haskell to Isar/HOL seems
    thus like the obvious next step to faciliate machine-aided verification of
    Haskell programs. Haskabelle is exactly such a converter.

       ;;; FIXME: Mentioning the original motivation (i.e. the verified OS
           endeavors of Australia) here?


   ___________________________________________________________________________

     [*] It can likewise be considered a superset of Haskell depending on your
         perspective, and your motivation.


* How does Haskabelle work?

     - working on ASTs only => no type inference

     - delegating work to Isabelle

     - only because a conversion succeeded, does not mean that Isabelle won't choke.


* What can we do?

    - module resolution

    - declarations

           + functions

           + constants

           + algebraic data types

           + classes & instances

           + monads

    - linearization of declarations

    - expressions

           + literals (integers, strings, characters)

           + applications, infix applications, sections

           + lambda abstractions

           + if, let, case

           + pattern guards

           + list comprehensions

           + records

* Customization

   ???

* Implementation Notes

    5 Phases

      - parsing

      - preprocessing

      - converting

      - adapting

      - printing


